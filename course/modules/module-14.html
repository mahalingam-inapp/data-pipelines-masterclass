<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 14: Warehouses, Lakes, Marts & Cubes</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f9f9f9; padding: 20px; color: #444; line-height: 1.6; }
        h2 { color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 8px; margin-bottom: 16px; }
        h3 { color: #764ba2; margin: 20px 0 10px; }
        .plain-terms { background: #f0f7ff; border-left: 4px solid #764ba2; padding: 15px; border-radius: 4px; margin: 16px 0; }
        .example-box { background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 20px; margin: 16px 0; }
        .step-box { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 18px; margin: 16px 0; }
        .info-box { background: #e8f4f8; border-left: 4px solid #667eea; padding: 15px; border-radius: 4px; margin: 16px 0; }
        table { border-collapse: collapse; width: 100%; margin: 12px 0; }
        th { background: #667eea; color: white; padding: 10px; }
        td { padding: 10px; border: 1px solid #e0e0e0; }
        tr:nth-child(even) { background: #f8f9fa; }
        .quiz-section { background: white; border: 2px solid #667eea; border-radius: 8px; padding: 24px; margin-top: 24px; }
        .quiz-question { background: #f8f9fa; border-left: 4px solid #764ba2; padding: 16px; margin: 12px 0; border-radius: 4px; }
        .quiz-options { list-style: none; padding-left: 0; }
        .quiz-options li { background: white; border: 1px solid #ddd; padding: 10px; margin: 6px 0; border-radius: 6px; }
        .quiz-answer { display: none; border-left: 4px solid #28a745; padding: 12px; margin-top: 8px; background: #d4edda; border-radius: 4px; }
        .quiz-answer.show { display: block; }
        .show-answer-btn { background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; margin-top: 8px; }
        .show-answer-btn:disabled { opacity: 0.7; cursor: not-allowed; background: #6c757d; }
        .key-insight { background: linear-gradient(135deg, #f0f7ff 0%, #e8f0ff 100%); border-left: 4px solid #764ba2; padding: 18px 20px; border-radius: 6px; margin: 20px 0; font-size: 1.05em; line-height: 1.7; }
        .key-insight strong { color: #764ba2; }
        .key-takeaways { background: #d4edda; border-left: 4px solid #28a745; padding: 20px; border-radius: 6px; margin: 24px 0; }
        .key-takeaways h4 { color: #155724; margin-top: 0; margin-bottom: 12px; font-size: 1.15em; }
        .key-takeaways ul { margin: 0; padding-left: 22px; }
        .key-takeaways li { margin-bottom: 8px; line-height: 1.6; }
        .code-block { background: #1e1e1e; color: #d4d4d4; border-radius: 8px; overflow: hidden; margin: 16px 0; }
        .code-lang { background: #333; color: #9cdcfe; padding: 8px 12px; font-size: 0.9em; }
        .code-block pre { margin: 0; padding: 16px; overflow-x: auto; }
        .code-block code { font-family: 'Consolas', 'Monaco', monospace; font-size: 0.9em; }
        .step-box { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 18px; margin: 16px 0; }
        h4 { color: #667eea; margin: 14px 0 8px; font-size: 1em; }
    </style>
</head>
<body>
    <h2>Module 14: Warehouses, Lakes, Marts & Cubes</h2>

    <h3>What Are Warehouses, Lakes, Marts, and Cubes?</h3>
    <p>Modern <strong>warehouses</strong> (cloud-native, managed) and <strong>lakes</strong> (object storage + query engines or lakehouse) are where Bronze/Silver/Gold often live. <strong>Partitioning</strong> (e.g. by date) and <strong>clustering</strong> improve query performance and cost. <strong>Marts</strong> are built from Gold (or Silver) for a specific audience; <strong>cubes</strong> (or semantic layers) pre-aggregate dimensions and measures for fast dashboards.</p>

    <div class="key-insight">
        <strong>Key insight:</strong> Partition by date for incremental loads and partition pruning; cluster for common filters. Build a mart when a team needs a dedicated view; add a cube when dashboard latency or concurrency demands it.
    </div>

    <h3>Same dummy data, different storage types: how it is represented</h3>
    <p>Using the <strong>NorthStar Retail</strong> scenario: the pipeline produces Gold with daily sales by product and region. Below is one consistent <strong>dummy source dataset</strong>, then how that same data is <strong>represented</strong> in each storage type (warehouse, lake, mart, cube, lakehouse).</p>

    <h4>Dummy source data (Gold-level outcome)</h4>
    <p>After Bronze → Silver → Gold, the business has three rows for 2025-01-08:</p>
    <div class="example-box">
        <table>
            <tr><th>sale_date</th><th>product_id</th><th>product_name</th><th>region_id</th><th>revenue</th><th>order_count</th></tr>
            <tr><td>2025-01-08</td><td>P1</td><td>Widget Pro</td><td>North</td><td>59.98</td><td>2</td></tr>
            <tr><td>2025-01-08</td><td>P2</td><td>Basic Cable</td><td>South</td><td>14.50</td><td>1</td></tr>
            <tr><td>2025-01-08</td><td>P3</td><td>Power Pack</td><td>West</td><td>49.00</td><td>1</td></tr>
        </table>
        <p style="margin:8px 0 0;font-size:0.9em;color:#666;">This is the logical “Gold” result. Below: how this same information is stored and accessed in each storage type.</p>
    </div>

    <h4>1. In a data warehouse</h4>
    <p>Data is stored as <strong>tables</strong> with a defined schema. Rows and columns; SQL is the interface. Partitioning (e.g. by <code>sale_date</code>) and clustering (e.g. by <code>region_id</code>, <code>product_id</code>) are metadata the engine uses for pruning and sorting.</p>
    <div class="example-box">
        <p><strong>Representation:</strong> One table <code>gold.daily_sales_by_product_region</code>. Same three rows; schema enforced at write.</p>
        <table>
            <tr><th>sale_date</th><th>product_id</th><th>product_name</th><th>region_id</th><th>revenue</th><th>order_count</th></tr>
            <tr><td>2025-01-08</td><td>P1</td><td>Widget Pro</td><td>North</td><td>59.98</td><td>2</td></tr>
            <tr><td>2025-01-08</td><td>P2</td><td>Basic Cable</td><td>South</td><td>14.50</td><td>1</td></tr>
            <tr><td>2025-01-08</td><td>P3</td><td>Power Pack</td><td>West</td><td>49.00</td><td>1</td></tr>
        </table>
        <p style="margin:8px 0 0;font-size:0.9em;color:#666;">Access: <code>SELECT * FROM gold.daily_sales_by_product_region WHERE sale_date = '2025-01-08'</code>. Data lives in the warehouse’s managed storage; no visible file paths.</p>
    </div>

    <h4>2. In a data lake</h4>
    <p>Data is stored as <strong>files</strong> in object storage. The same logical data can appear in different formats and paths at each layer. No single “table” unless a catalog or engine exposes one.</p>
    <div class="example-box">
        <p><strong>Representation:</strong> Files under paths; format and layout differ by layer.</p>
        <ul style="margin:8px 0;">
            <li><strong>Landing (raw):</strong> <code>landing/sales/sales_20250108.csv</code> — same data as rows in CSV (one row per transaction before aggregation). Example snippet:</li>
        </ul>
        <pre style="margin:8px 0;padding:10px;background:#f5f5f5;border-radius:4px;font-size:0.85em;">sale_id,product_id,region_id,amount,sale_date
101,P1,North,29.99,2025-01-08
102,P2,South,14.50,2025-01-08
103,P1,North,29.99,2025-01-08
104,P3,West,49.00,2025-01-08</pre>
        <ul style="margin:8px 0;">
            <li><strong>Bronze:</strong> <code>bronze/sales_raw/ingestion_date=2025-01-08/</code> — Parquet files, same rows plus <code>_ingested_at</code>, <code>_source_file</code>.</li>
            <li><strong>Gold:</strong> <code>gold/daily_sales_by_product_region/sale_date=2025-01-08/</code> — Parquet with one partition; file contains the three aggregated rows (sale_date, product_id, product_name, region_id, revenue, order_count).</li>
        </ul>
        <p style="margin:8px 0 0;font-size:0.9em;color:#666;">Access: read the path with Spark, Athena, or Pandas; e.g. <code>pd.read_parquet("gold/daily_sales_by_product_region/", filters=[("sale_date","==","2025-01-08")])</code>. The “table” is a convention (path + format + optional catalog).</p>
    </div>

    <h4>3. In a data mart</h4>
    <p>Data is a <strong>subset</strong> of Gold (or Silver): same or fewer columns, possibly filtered rows, in a dedicated schema or database for one team. Representation is still rows and columns (like the warehouse), but scoped to the mart.</p>
    <div class="example-box">
        <p><strong>Representation:</strong> Mart table <code>mart_regional_sales.daily_sales_by_region</code> — same three rows, possibly same columns, or a view that drops <code>product_id</code> and aggregates to region-only for a simpler report.</p>
        <table>
            <tr><th>sale_date</th><th>region_id</th><th>revenue</th><th>order_count</th></tr>
            <tr><td>2025-01-08</td><td>North</td><td>59.98</td><td>2</td></tr>
            <tr><td>2025-01-08</td><td>South</td><td>14.50</td><td>1</td></tr>
            <tr><td>2025-01-08</td><td>West</td><td>49.00</td><td>1</td></tr>
        </table>
        <p style="margin:8px 0 0;font-size:0.9em;color:#666;">Here the mart view aggregates to <strong>region only</strong> (one row per date + region) so the regional team sees totals per region. Same underlying Gold data; different grain in the mart.</p>
    </div>

    <h4>4. In a cube (semantic layer)</h4>
    <p>Data is represented as <strong>dimensions</strong> and <strong>measures</strong>. The same Gold rows feed the cube; the cube stores pre-aggregated results or definitions so queries return quickly. Users see pivot-style results, not raw rows.</p>
    <div class="example-box">
        <p><strong>Representation:</strong> Dimensions: <strong>Date</strong> (sale_date), <strong>Product</strong> (product_id, product_name, category), <strong>Region</strong> (region_id). Measures: <strong>Revenue</strong> = SUM(revenue), <strong>Order count</strong> = SUM(order_count).</p>
        <p>Example “query” result (Revenue by Region for 2025-01-08) — what a dashboard gets from the cube:</p>
        <table>
            <tr><th>Region</th><th>Revenue</th><th>Order count</th></tr>
            <tr><td>North</td><td>59.98</td><td>2</td></tr>
            <tr><td>South</td><td>14.50</td><td>1</td></tr>
            <tr><td>West</td><td>49.00</td><td>1</td></tr>
        </table>
        <p style="margin:8px 0 0;font-size:0.9em;color:#666;">The cube might store this aggregate or compute it on demand from Gold. Difference from warehouse: access is through the cube’s semantic layer (e.g. “Revenue by Region”), not direct SQL on the fact table.</p>
    </div>

    <h4>5. In a lakehouse</h4>
    <p>Data is stored as <strong>tables</strong> (like the warehouse) but the physical storage is <strong>object storage</strong> with a table format (Delta, Iceberg). Same logical rows and columns; you query with SQL. The difference is where files live and that the table has ACID and time travel.</p>
    <div class="example-box">
        <p><strong>Representation:</strong> Table <code>gold.daily_sales_by_product_region</code> — same three rows and schema as the warehouse example. Physically: files under e.g. <code>s3://bucket/gold/daily_sales_by_product_region/sale_date=2025-01-08/</code> in Delta format (Parquet + transaction log).</p>
        <table>
            <tr><th>sale_date</th><th>product_id</th><th>product_name</th><th>region_id</th><th>revenue</th><th>order_count</th></tr>
            <tr><td>2025-01-08</td><td>P1</td><td>Widget Pro</td><td>North</td><td>59.98</td><td>2</td></tr>
            <tr><td>2025-01-08</td><td>P2</td><td>Basic Cable</td><td>South</td><td>14.50</td><td>1</td></tr>
            <tr><td>2025-01-08</td><td>P3</td><td>Power Pack</td><td>West</td><td>49.00</td><td>1</td></tr>
        </table>
        <p style="margin:8px 0 0;font-size:0.9em;color:#666;">Access: <code>SELECT * FROM gold.daily_sales_by_product_region WHERE sale_date = '2025-01-08'</code> — same SQL as warehouse. The engine reads Delta files from the path; catalog points to the table location.</p>
    </div>

    <div class="plain-terms"><strong>Summary:</strong> Same dummy data (three Gold rows for 2025-01-08). <strong>Warehouse</strong> = table, SQL. <strong>Lake</strong> = files (CSV/Parquet) in paths by layer. <strong>Mart</strong> = subset table/view (e.g. region-only grain). <strong>Cube</strong> = dimensions + measures, pivot-style results. <strong>Lakehouse</strong> = table over object storage (Delta/Iceberg), same SQL as warehouse.</div>

    <h3>Data storage methods: formats and when to use them</h3>
    <p>Where and how you store data determines cost, speed, and who can query it. <strong>Components</strong>: (1) storage backend (object store vs. warehouse), (2) file format (Parquet, Delta, CSV, JSON), (3) partition layout (e.g. by date), (4) catalog (for discovery and SQL).</p>
    <table>
        <tr><th>Format</th><th>Typical use</th><th>Pros</th><th>Cons</th></tr>
        <tr><td><strong>Parquet</strong></td><td>Silver/Gold in lake; analytics</td><td>Columnar, compressed, schema embedded; fast column scans</td><td>Not human-readable; append/update needs care</td></tr>
        <tr><td><strong>Delta / Iceberg</strong></td><td>Lakehouse; ACID, upserts</td><td>ACID, time travel, merge; table semantics on files</td><td>More complex; requires compatible engine</td></tr>
        <tr><td><strong>CSV</strong></td><td>Landing, exports, small datasets</td><td>Universal, human-readable</td><td>No schema; slow for large scans; type ambiguity</td></tr>
        <tr><td><strong>JSON</strong></td><td>Bronze (raw API/logs); semi-structured</td><td>Flexible schema; good for nested data</td><td>Verbose; slower for analytical queries</td></tr>
    </table>
    <p><strong>Process:</strong> Data is written to a path (e.g. <code>s3://bucket/silver/sales/year=2025/month=02/</code>). A catalog registers the table so SQL engines can filter by partition. <strong>Outcome:</strong> partition pruning, lower cost, faster queries.</p>

    <h3>Warehouses and lakes in detail</h3>
    <p>Bronze is often in object storage (files); Silver and Gold in a warehouse or lakehouse. Use partitioning (e.g. by date) for incremental loads and partition pruning. Compression and access control (encryption, RBAC) apply to both.</p>

    <h4>Python: write and read Parquet (lake-style)</h4>
    <p>Write Parquet with a date-partitioned folder layout so downstream engines can prune partitions.</p>
    <div class="code-block">
        <div class="code-lang">Python (pandas + pyarrow): write partitioned Parquet</div>
        <pre><code>import pandas as pd
df = pd.DataFrame({"sale_date": ["2025-02-01", "2025-02-01"], "product_id": [101, 102], "revenue": [100.0, 250.0]})
df["sale_date"] = pd.to_datetime(df["sale_date"])
base_path = "/data/silver/sales"  # or s3://bucket/silver/sales
df.to_parquet(base_path, engine="pyarrow", partition_cols=["sale_date"], index=False)
# Read one partition only:
df_subset = pd.read_parquet(base_path, filters=[("sale_date", "==", "2025-02-01")])</code></pre>
    </div>

    <h4>R: read and write Parquet</h4>
    <p>R analysts read from the same storage pipelines produce. The <code>arrow</code> package supports partition pruning.</p>
    <div class="code-block">
        <div class="code-lang">R (arrow): read Parquet; filter at read time</div>
        <pre><code>library(arrow)
ds <- open_dataset("/data/silver/sales")
tbl <- ds %>% filter(sale_date == as.Date("2025-02-01")) %>% collect()
write_parquet(mart_sales_df, "s3://bucket/mart/sales_snapshot.parquet")</code></pre>
    </div>

    <h4>Warehouse: partitioning and clustering (SQL)</h4>
    <p>In a warehouse, define partition and cluster keys; the engine prunes when you filter. <strong>Outcome:</strong> faster queries, lower compute.</p>
    <div class="code-block">
        <div class="code-lang">SQL: partitioned and clustered table</div>
        <pre><code>CREATE TABLE gold.daily_sales (
  sale_date DATE, product_id INT, region_id INT, revenue DECIMAL(18,2), units_sold INT
) PARTITION BY (sale_date) CLUSTER BY (region_id, product_id);
SELECT region_id, SUM(revenue) FROM gold.daily_sales
WHERE sale_date BETWEEN '2025-02-01' AND '2025-02-07' GROUP BY region_id;</code></pre>
    </div>

    <h3>Data marts and cubes: what they are physically</h3>
    <p><strong>Mart:</strong> A subset of tables or views from Gold/Silver for one domain (e.g. Sales mart: fact_sales, dim_product, dim_region). <strong>Cube:</strong> Pre-aggregated dimensions and measures for fast BI; tools include Analysis Services, Looker semantic layer, Power BI datasets, Tableau data model. <strong>Process:</strong> Gold is aggregated into mart tables/views; cube defines dimensions and measures. <strong>Outcome:</strong> consistent definitions, sub-second dashboards, less warehouse load.</p>
    <div class="step-box">
        <p><strong>Mart example (SQL):</strong> View from Gold for the sales team.</p>
        <pre><code>CREATE VIEW mart_sales.sales_by_region AS
SELECT sale_date, region_id, product_id, SUM(revenue) AS revenue, SUM(units_sold) AS units
FROM gold.daily_sales GROUP BY sale_date, region_id, product_id;</code></pre>
    </div>
    <p>Build a mart when a team needs a dedicated view; add a cube when dashboard latency or concurrency demands it.</p>

    <div class="key-takeaways">
        <h4>Key Takeaways</h4>
        <ul>
            <li>Bronze often in object storage; Silver/Gold in warehouse or lakehouse; partition by date, use clustering.</li>
            <li>Mart = subset for one domain/team; cube = dimensions + measures for fast, concurrent dashboards.</li>
            <li>Storage formats: Parquet/Delta for analytics; CSV/JSON for landing; use Python (pandas/pyarrow) or R (arrow) to read/write with partition pruning.</li>
            <li>Partitioning enables incremental loads and partition pruning; compression and RBAC for governance.</li>
        </ul>
    </div>

    <h3>Real-World Applications</h3>
    <ul>
        <li><strong>Sales team:</strong> Mart from Gold (sales, product, region); cube for exec revenue dashboard.</li>
    </ul>

    <div class="info-box"><strong>Relationship to other modules:</strong> Module 13 introduced storage types; this one deepens implementation. Module 15 is the use case (Storage Strategy). Section 6 (Modules 16–19) connects storage to Power BI and Tableau.</div>
    <div class="quiz-section">
        <h3>Module Quiz</h3>
        <div class="quiz-question">
            <h4>Q1: Why partition a table by date?</h4>
            <ul class="quiz-options"><li>A) To reduce storage</li><li>B) To support incremental loads and partition pruning (faster, cheaper queries)</li></ul>
            <button class="show-answer-btn" id="btn-1" onclick="showAnswer(1)">Show Answer</button>
            <div class="quiz-answer" id="answer-1"><strong>Correct: B.</strong> Partitioning by date lets you read/write only relevant partitions and skip others.</div>
        </div>
        <div class="quiz-question">
            <h4>Q2: What is clustering used for?</h4>
            <ul class="quiz-options"><li>A) Encrypting data</li><li>B) Ordering data within a partition for better range and join performance</li></ul>
            <button class="show-answer-btn" id="btn-2" onclick="showAnswer(2)">Show Answer</button>
            <div class="quiz-answer" id="answer-2"><strong>Correct: B.</strong> Clustering improves query performance by organizing data by key columns.</div>
        </div>
        <div class="quiz-question">
            <h4>Q3: When should you build a data mart?</h4>
            <ul class="quiz-options"><li>A) Never</li><li>B) When a team needs a dedicated, simplified view for a domain</li></ul>
            <button class="show-answer-btn" id="btn-3" onclick="showAnswer(3)">Show Answer</button>
            <div class="quiz-answer" id="answer-3"><strong>Correct: B.</strong> Marts simplify access and ownership for a specific audience.</div>
        </div>
        <div class="quiz-question">
            <h4>Q4: When should you add a cube or semantic layer?</h4>
            <ul class="quiz-options"><li>A) Only for raw data</li><li>B) When dashboard latency or concurrency demands sub-second response</li></ul>
            <button class="show-answer-btn" id="btn-4" onclick="showAnswer(4)">Show Answer</button>
            <div class="quiz-answer" id="answer-4"><strong>Correct: B.</strong> Cubes pre-aggregate for fast BI.</div>
        </div>
        <div class="quiz-question">
            <h4>Q5: Where do Silver and Gold typically live?</h4>
            <ul class="quiz-options"><li>A) Only in object storage</li><li>B) In a warehouse or lakehouse so they can be queried with SQL</li></ul>
            <button class="show-answer-btn" id="btn-5" onclick="showAnswer(5)">Show Answer</button>
            <div class="quiz-answer" id="answer-5"><strong>Correct: B.</strong> Silver and Gold need SQL and performance; warehouse or lakehouse provides that.</div>
        </div>
    </div>
    <script>function showAnswer(n){var a=document.getElementById('answer-'+n),b=document.getElementById('btn-'+n);if(a&&b){a.classList.add('show');b.disabled=true;b.textContent='Answer Revealed';}}</script>
<script>(function(){function sendHeight(){try{var body=document.body,html=document.documentElement;var h=Math.max(body.scrollHeight,body.offsetHeight,html.scrollHeight,html.offsetHeight,html.clientHeight||0);if(h<=0)return;var path=window.location.pathname||window.location.href||'';var m=path.match(/module-(\d+)\.html/);if(m)window.parent.postMessage({type:'setIframeHeight',height:h,moduleId:parseInt(m[1],10)},'*');}catch(e){}}sendHeight();setTimeout(sendHeight,100);setTimeout(sendHeight,400);setTimeout(sendHeight,1000);})();</script>
</body>
</html>
