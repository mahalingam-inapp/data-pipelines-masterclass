<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 13: Storage Types & Trade-offs</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f9f9f9; padding: 20px; color: #444; line-height: 1.6; }
        h2 { color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 8px; margin-bottom: 16px; }
        h3 { color: #764ba2; margin: 20px 0 10px; }
        .plain-terms { background: #f0f7ff; border-left: 4px solid #764ba2; padding: 15px; border-radius: 4px; margin: 16px 0; }
        .example-box { background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 20px; margin: 16px 0; }
        .step-box { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 18px; margin: 16px 0; }
        .info-box { background: #e8f4f8; border-left: 4px solid #667eea; padding: 15px; border-radius: 4px; margin: 16px 0; }
        table { border-collapse: collapse; width: 100%; margin: 12px 0; }
        th { background: #667eea; color: white; padding: 10px; }
        td { padding: 10px; border: 1px solid #e0e0e0; }
        tr:nth-child(even) { background: #f8f9fa; }
        .quiz-section { background: white; border: 2px solid #667eea; border-radius: 8px; padding: 24px; margin-top: 24px; }
        .quiz-question { background: #f8f9fa; border-left: 4px solid #764ba2; padding: 16px; margin: 12px 0; border-radius: 4px; }
        .quiz-options { list-style: none; padding-left: 0; }
        .quiz-options li { background: white; border: 1px solid #ddd; padding: 10px; margin: 6px 0; border-radius: 6px; }
        .quiz-answer { display: none; border-left: 4px solid #28a745; padding: 12px; margin-top: 8px; background: #d4edda; border-radius: 4px; }
        .quiz-answer.show { display: block; }
        .show-answer-btn { background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; margin-top: 8px; }
        .show-answer-btn:disabled { opacity: 0.7; cursor: not-allowed; background: #6c757d; }
        .diagram-box { background: #fff; border: 2px solid #e0e0e0; border-radius: 8px; padding: 20px; margin: 20px 0; overflow-x: auto; }
        .diagram-box .diagram-title { font-weight: bold; color: #764ba2; margin-bottom: 12px; }
        .diagram-box img.storage-diagram { max-width: 100%; height: auto; border-radius: 8px; display: block; margin: 0 auto; }
        .code-block { margin: 16px 0; border-radius: 8px; overflow: hidden; border: 1px solid #ddd; }
        .code-block .code-lang { background: #667eea; color: white; padding: 6px 12px; font-size: 0.85em; }
        .code-block pre { margin: 0; padding: 14px; background: #1e1e1e; color: #d4d4d4; font-size: 0.9em; overflow-x: auto; }
        .key-insight { background: linear-gradient(135deg, #f0f7ff 0%, #e8f0ff 100%); border-left: 4px solid #764ba2; padding: 18px 20px; border-radius: 6px; margin: 20px 0; font-size: 1.05em; line-height: 1.7; }
        .key-insight strong { color: #764ba2; }
        .key-takeaways { background: #d4edda; border-left: 4px solid #28a745; padding: 20px; border-radius: 6px; margin: 24px 0; }
        .key-takeaways h4 { color: #155724; margin-top: 0; margin-bottom: 12px; font-size: 1.15em; }
        .key-takeaways ul { margin: 0; padding-left: 22px; }
        .key-takeaways li { margin-bottom: 8px; line-height: 1.6; }
        h4 { color: #667eea; margin: 14px 0 8px; font-size: 1em; }
        .highlight-box { background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; border-radius: 4px; margin: 16px 0; }
    </style>
</head>
<body>
    <h2>Module 13: Storage Types & Trade-offs</h2>

    <h3>What Are the Main Storage Types?</h3>
    <p>Where you store data depends on how it will be used. A <strong>data warehouse</strong> is structured, SQL-friendly, for reporting and analytics. A <strong>data lake</strong> holds files at scale (raw events, diverse formats). A <strong>data mart</strong> is a subset for one team or use case. A <strong>cube</strong> (or semantic layer) is pre-aggregated for fast BI. A <strong>lakehouse</strong> combines lake scale with warehouse-style tables and ACID.</p>

    <div class="key-insight">
        <strong>Key insight:</strong> Warehouse for curated SQL and reporting; lake for raw and ML; mart for a team subset; cube for fast dashboards. Lakehouse gives you both—cheap storage and SQL/ACID—so Bronze can live in the lake and Silver/Gold be queried like a warehouse.
    </div>

    <div class="diagram-box">
        <div class="diagram-title">Storage landscape: where data lives</div>
        <svg viewBox="0 0 480 95" xmlns="http://www.w3.org/2000/svg" style="max-width:100%;height:auto;">
            <rect x="10" y="15" width="110" height="38" rx="4" fill="#e8f0ff" stroke="#667eea"/><text x="65" y="35" text-anchor="middle" font-size="11">Warehouse</text><text x="65" y="48" text-anchor="middle" font-size="9" fill="#666">SQL, reporting</text>
            <rect x="130" y="15" width="110" height="38" rx="4" fill="#e8f4f8" stroke="#667eea"/><text x="185" y="35" text-anchor="middle" font-size="11">Lake</text><text x="185" y="48" text-anchor="middle" font-size="9" fill="#666">raw, files, ML</text>
            <rect x="250" y="15" width="110" height="38" rx="4" fill="#fff3cd" stroke="#ffc107"/><text x="305" y="35" text-anchor="middle" font-size="11">Mart</text><text x="305" y="48" text-anchor="middle" font-size="9" fill="#666">team subset</text>
            <rect x="370" y="15" width="105" height="38" rx="4" fill="#d4edda" stroke="#28a745"/><text x="422" y="35" text-anchor="middle" font-size="11">Cube</text><text x="422" y="48" text-anchor="middle" font-size="9" fill="#666">fast BI</text>
            <text x="65" y="78" text-anchor="middle" font-size="9" fill="#666">curated tables</text>
            <text x="185" y="78" text-anchor="middle" font-size="9" fill="#666">Parquet, JSON</text>
            <text x="305" y="78" text-anchor="middle" font-size="9" fill="#666">subject-area</text>
            <text x="422" y="78" text-anchor="middle" font-size="9" fill="#666">pre-aggregated</text>
            <rect x="175" y="55" width="130" height="28" rx="4" fill="#f0f7ff" stroke="#764ba2" stroke-dasharray="4"/><text x="240" y="73" text-anchor="middle" font-size="10">Lakehouse = Lake + tables + ACID</text>
        </svg>
    </div>

    <div class="diagram-box">
        <div class="diagram-title">Visual overview: five storage types</div>
        <p style="margin-bottom:12px;">The image below summarizes where each storage type fits: <strong>Warehouse</strong> (SQL, curated), <strong>Lake</strong> (raw files, ML), <strong>Mart</strong> (team subset), <strong>Cube</strong> (fast BI), and <strong>Lakehouse</strong> (lake + tables + ACID).</p>
        <img src="storage-types-diagram.png" alt="Diagram: Warehouse, Lake, Mart, Cube, and Lakehouse storage types with short descriptors" class="storage-diagram" width="800" />
    </div>

    <h3>When to use which</h3>
    <div class="step-box">
        <table>
            <tr><th>Storage</th><th>Typical use</th></tr>
            <tr><td>Warehouse</td><td>Reporting, ad hoc SQL, curated tables</td></tr>
            <tr><td>Lake</td><td>Raw events, ML features, archival, diverse formats</td></tr>
            <tr><td>Mart</td><td>Subject-area subset (e.g. “Marketing performance”, “Supply chain”)</td></tr>
            <tr><td>Cube</td><td>Executive dashboards, sub-second response, drill-down</td></tr>
            <tr><td>Lakehouse</td><td>One platform for raw + curated; SQL and ML on same storage; lower cost than warehouse-only</td></tr>
        </table>
    </div>

    <h3>Storage types in detail</h3>
    <p>Below: what each type does, where it helps, example technologies, a dummy example, and how it fits into pipeline design.</p>

    <h4>1. Data warehouse</h4>
    <p><strong>What it does:</strong> A warehouse stores structured data with a defined schema (schema-on-write). Data is organized in tables, optimized for analytical queries (columnar storage, indexes), and accessed via SQL. It provides ACID transactions, access control, and tight integration with BI tools.</p>
    <p><strong>Where it's helpful:</strong> Curated reporting tables (Silver/Gold), ad hoc SQL by analysts, governed dashboards, and any use case where you need consistent metrics, role-based access, and fast aggregations over clean data. It is the default home for "single source of truth" business tables.</p>
    <p><strong>Example technologies:</strong> Snowflake, Google BigQuery, Amazon Redshift, Azure Synapse Analytics, Databricks SQL (warehouse tier), Oracle Autonomous Data Warehouse, Teradata.</p>
    <div class="example-box">
        <h4>Dummy example: NorthStar Retail warehouse</h4>
        <p>NorthStar loads <code>gold.daily_sales_by_product_region</code> into a Snowflake database. Analysts run <code>SELECT sale_date, region_id, SUM(revenue) FROM gold.daily_sales_by_product_region WHERE sale_date BETWEEN '2025-01-01' AND '2025-01-31' GROUP BY sale_date, region_id</code> in Tableau. Finance has a separate schema with PII masked. The pipeline writes only new partitions (incremental by <code>sale_date</code>) so full-table scans are avoided.</p>
    </div>
    <div class="plain-terms"><strong>Pipeline design:</strong> Silver and Gold tables are typically written to the warehouse. Use staging tables (e.g. <code>staging.daily_sales_stg</code>) for each load, then merge or insert into the target table. Partition (or cluster) by date for incremental loads and partition pruning. Run quality checks after load; expose only certified tables to analysts.</div>

    <h4>2. Data lake</h4>
    <p><strong>What it does:</strong> A lake is object storage (blobs or files) that holds data in file formats such as CSV, JSON, Parquet, or ORC. There is no single schema enforced at write time (schema-on-read). You can store raw landing data, Bronze layers, and large volumes at low cost. Query engines (Spark, Athena, Presto) read files on demand.</p>
    <p><strong>Where it's helpful:</strong> Landing zones (raw payloads for replay and audit), Bronze and sometimes Silver when you want cheap storage and flexibility. Data science and ML (feature store, training data). Compliance and long-term retention. When you have many sources or formats (logs, events, APIs) that don't all need to be in a warehouse yet.</p>
    <p><strong>Example technologies:</strong> Amazon S3, Azure Data Lake Storage (ADLS), Google Cloud Storage (GCS), MinIO (self-hosted). Often used with Apache Spark, AWS Athena, Presto/Trino, or Databricks for querying.</p>
    <div class="example-box">
        <h4>Dummy example: NorthStar lake layout</h4>
        <p><code>landing/sales/</code> holds daily CSVs (e.g. <code>sales_2025-01-08.csv</code>). <code>bronze/sales_raw/</code> is Parquet partitioned by <code>ingestion_date</code>. A data scientist reads <code>bronze/sales_raw</code> and <code>silver/products</code> (also Parquet) in a notebook to build a "revenue by product category" feature set for a model. No data is duplicated into the warehouse until Gold is published.</p>
    </div>
    <div class="plain-terms"><strong>Pipeline design:</strong> Landing and Bronze live in the lake; use a consistent layout (e.g. <code>bronze/source_name/partition_col=value/</code>). Prefer columnar formats (Parquet) for any layer that will be queried. Partition by date (or ingestion time) for incremental jobs. If Silver or Gold are in the lake, use a table format (Delta, Iceberg) or a separate warehouse for SQL workloads.</div>

    <h4>3. Data mart</h4>
    <p><strong>What it does:</strong> A mart is a focused subset of data for one team or subject area. It can be a dedicated schema, database, or set of views/tables that contain only the dimensions and facts relevant to that audience (e.g. "Marketing performance", "Supply chain"). It often derives from the central warehouse or Gold layer.</p>
    <p><strong>Where it's helpful:</strong> Reducing load on the central warehouse; giving a team only the tables and rows they need; enforcing subject-area boundaries and SLAs. Marketing might have a mart with campaigns and conversions; supply chain with inventory and orders. Each mart can have its own refresh schedule and access rules.</p>
    <p><strong>Example technologies:</strong> Often the same platform as the warehouse (e.g. a Snowflake schema <code>mart_marketing</code>, BigQuery dataset <code>mart_supply_chain</code>). Can also be a separate database (e.g. PostgreSQL) or a virtual mart built from views over the warehouse.</p>
    <div class="example-box">
        <h4>Dummy example: Regional sales mart</h4>
        <p>NorthStar creates a mart <code>mart_regional_sales</code> with one table: <code>daily_sales_by_region</code> (sale_date, region_id, product_name, revenue, order_count), plus a small <code>dim_region</code>. Only the sales and operations teams have access. The mart is refreshed daily from <code>gold.daily_sales_by_product_region</code> right after the Gold job runs. Analysts never query the central Gold table directly for regional reports—they use the mart.</p>
    </div>
    <div class="plain-terms"><strong>Pipeline design:</strong> Marts are fed from Gold (or Silver). Add a pipeline stage "Refresh mart" that runs after Gold: either <code>INSERT OVERWRITE</code> or a view. Document which Gold tables feed which mart and the refresh order. Marts can be views (no storage cost, always current) or materialized tables (faster queries, refresh on schedule).</div>

    <h4>4. Cube / semantic layer</h4>
    <p><strong>What it does:</strong> A cube (or semantic layer) exposes pre-aggregated dimensions and measures to BI tools. Queries hit the cube instead of the raw fact table, so response times are sub-second and metrics (e.g. "Revenue") are defined in one place. Users drill down by dimensions (date, product, region) without writing SQL.</p>
    <p><strong>Where it's helpful:</strong> Executive dashboards, high concurrency, and consistent definitions across reports. When many users need the same metrics with different filters, the cube avoids heavy queries on the warehouse and ensures one definition of "revenue" or "order count."</p>
    <p><strong>Example technologies:</strong> Looker (LookML), Cube.dev, Apache Kylin, AtScale, Power BI aggregation tables / semantic models, Druid, or embedded semantic layers in BI tools (Tableau data model, MicroStrategy).</p>
    <div class="example-box">
        <h4>Dummy example: NorthStar exec dashboard cube</h4>
        <p>The cube has dimensions: <strong>Date</strong> (sale_date), <strong>Product</strong> (product_id, product_name, category), <strong>Region</strong> (region_id). Measures: <strong>Revenue</strong> = SUM(revenue), <strong>Order count</strong> = SUM(order_count). The CEO dashboard shows Revenue by Region for the current month; clicking a region drills to Product. All queries hit the cube; the warehouse Gold table is only updated daily, and the cube is refreshed after Gold.</p>
    </div>
    <div class="plain-terms"><strong>Pipeline design:</strong> The cube is built from Gold (or a mart). Add a stage "Refresh cube / semantic model" after the Gold load. Pipeline order: Gold → (optional mart) → cube refresh. No raw or Bronze data in the cube—only business-level aggregates and dimensions. Document the cube's source table and refresh SLA (e.g. "Cube reflects data as of 08:00").</div>

    <h4>5. Lakehouse</h4>
    <p><strong>What it does:</strong> A lakehouse keeps data in object storage (like a lake) but adds a table format (e.g. Delta Lake, Apache Iceberg) that provides ACID transactions, schema enforcement, and time travel. You can run SQL on the same storage where raw and curated data live—no separate warehouse required for querying.</p>
    <p><strong>Where it's helpful:</strong> When you want one platform for landing, Bronze, Silver, and Gold: cheap storage, SQL, and ML on the same data. Unifying data engineering and data science; reducing copies and latency. Good when you're cloud-native and want to avoid loading everything into a traditional warehouse.</p>
    <p><strong>Example technologies:</strong> Databricks (Delta Lake), Apache Iceberg (e.g. with Spark, Athena, or Snowflake), Apache Hudi. Delta Lake can sit on S3, ADLS, or GCS; Iceberg and Hudi are open formats that work across engines.</p>
    <div class="example-box">
        <h4>Dummy example: NorthStar on a lakehouse</h4>
        <p>Bronze tables (<code>bronze.sales_raw</code>, <code>bronze.products_raw</code>) are Delta tables on S3. Silver and Gold (<code>silver.sales_enriched</code>, <code>gold.daily_sales_by_product_region</code>) are also Delta on S3. One Databricks or Spark job reads landing files, writes Bronze, then runs SQL to build Silver and Gold. Analysts query <code>gold.daily_sales_by_product_region</code> with SQL; data scientists read the same paths with Spark. No separate copy into a warehouse.</p>
    </div>
    <div class="plain-terms"><strong>Pipeline design:</strong> Use one catalog and object store for all layers. Bronze: append-only Delta/Iceberg with <code>_ingested_at</code>; Silver/Gold: merge or overwrite by partition. Enable time travel for debugging. Orchestration (e.g. Airflow, Databricks Workflows) runs the same medallion steps; the only difference from "warehouse" is that tables live on object storage with a table format instead of in a dedicated warehouse engine.</div>

    <h3>Reading and writing formats: Python and R</h3>
    <p><strong>Process:</strong> Data lands in a format (CSV, JSON, Parquet); you choose format by use case (landing = CSV/JSON, analytics = Parquet). <strong>Components:</strong> file or table, schema (explicit or inferred), and optional partitioning. <strong>Outcome:</strong> correct types, smaller size (Parquet), and partition pruning when applicable.</p>
    <div class="code-block">
        <div class="code-lang">Python: read CSV (landing), write Parquet (Silver)</div>
        <pre><code>import pandas as pd
# Landing: read CSV as-is
df = pd.read_csv("landing/sales_2025-02-01.csv")
# Infer or set types before writing to Silver
df["sale_date"] = pd.to_datetime(df["sale_date"])
df["revenue"] = pd.to_numeric(df["revenue"], errors="coerce")
# Write analytics-ready Parquet (columnar, compressed)
df.to_parquet("silver/sales.parquet", index=False)</code></pre>
    </div>
    <div class="code-block">
        <div class="code-lang">Python: read JSON (e.g. API payload in Bronze)</div>
        <pre><code># Nested JSON from API or logs
with open("bronze/events.json") as f:
    df = pd.read_json(f)
# Flatten if needed: pd.json_normalize(records)</code></pre>
    </div>
    <div class="code-block">
        <div class="code-lang">R: read CSV and Parquet; compare size</div>
        <pre><code>library(readr)
library(arrow)
# Landing: CSV
sales_csv <- read_csv("landing/sales_2025-02-01.csv")
# Silver: Parquet (smaller, faster for column scans)
sales_pq <- read_parquet("silver/sales.parquet")
# Same data in Parquet is typically 5–10x smaller than CSV</code></pre>
    </div>

    <h3>Example: Partitioned table (warehouse / lakehouse)</h3>
    <p>Partitioning by date lets you read/write only relevant data. Example DDL pattern:</p>
    <div class="code-block">
        <div class="code-lang">SQL (conceptual)</div>
        <pre><code>CREATE TABLE gold.daily_sales (
  sale_date DATE,
  product_id INT,
  region_id INT,
  revenue DECIMAL(18,2),
  units_sold INT
)
PARTITION BY (sale_date);  -- or PARTITION BY RANGE (sale_date)
-- Enables: SELECT ... WHERE sale_date = '2025-01-15' (only that partition scanned)</code></pre>
    </div>

    <p><strong>Trade-offs:</strong> Cost (storage and compute), performance (query latency, throughput), concurrency (many users querying at once), and governance (access control, audit). A <strong>lakehouse</strong> combines object storage (lake) with table formats and ACID semantics (warehouse-style), so you can keep Bronze in cheap storage and query Silver/Gold with SQL. If you only have a warehouse today, consider adding a lake when you need raw retention for compliance or replay, ML feature storage, or very large volume at lower cost.</p>
    <h3>Cost and performance</h3>
    <p>Warehouses charge for compute and storage; optimizing queries (partitioning, clustering, reducing full scans) reduces cost. Lakes typically have lower storage cost and pay-per-query or separate compute (e.g. Spark). Marts and cubes reduce load on the main warehouse by pre-aggregating or materializing for specific use cases.</p>

    <div class="key-takeaways">
        <h4>Key Takeaways</h4>
        <ul>
            <li>Warehouse: schema-on-write, SQL, curated Silver/Gold; Lake: object storage, schema-on-read, landing/Bronze/ML; Mart: subject-area subset; Cube: pre-aggregated dimensions and measures for fast BI; Lakehouse: lake + table format + ACID.</li>
            <li>Each type has a place: warehouse for governed reporting; lake for raw retention and ML; mart to isolate team data; cube for dashboards; lakehouse to unify pipeline and queries on one store.</li>
            <li>Pipeline design differs by type: warehouse = staging then merge, partition by date; lake = consistent paths, Parquet, partition by date; mart = refresh after Gold; cube = refresh after Gold; lakehouse = one catalog, Bronze append, Silver/Gold merge.</li>
            <li>Use Python (pandas) or R (readr, arrow) to read CSV/JSON from landing and write Parquet for Silver; partition by date for incremental loads and partition pruning.</li>
        </ul>
    </div>

    <h3>Real-World Applications</h3>
    <ul>
        <li><strong>Start with warehouse:</strong> Add lake for raw retention, replay, or ML; add mart for team; add cube for exec dashboards.</li>
    </ul>

    <div class="info-box"><strong>Relationship to other modules:</strong> Module 14 goes into warehouses, lakes, marts, and cubes in more detail; Module 15 is the use case (Storage Strategy).</div>
    <div class="quiz-section">
        <h3>Module Quiz</h3>
        <div class="quiz-question">
            <h4>Q1: What is a data mart?</h4>
            <ul class="quiz-options"><li>A) A full copy of the warehouse</li><li>B) A subject-area subset for a team or use case</li></ul>
            <button class="show-answer-btn" id="btn-1" onclick="showAnswer(1)">Show Answer</button>
            <div class="quiz-answer" id="answer-1"><strong>Correct: B.</strong> Marts are focused subsets (schema/tables) for specific analytics or teams.</div>
        </div>
        <div class="quiz-question">
            <h4>Q2: What is a lakehouse?</h4>
            <ul class="quiz-options"><li>A) Only a lake</li><li>B) Combines object storage (lake) with table formats and ACID semantics (warehouse-style)</li></ul>
            <button class="show-answer-btn" id="btn-2" onclick="showAnswer(2)">Show Answer</button>
            <div class="quiz-answer" id="answer-2"><strong>Correct: B.</strong> Lakehouse gives scale and cost of a lake with SQL and consistency of a warehouse.</div>
        </div>
        <div class="quiz-question">
            <h4>Q3: When might you add a data lake if you already have a warehouse?</h4>
            <ul class="quiz-options"><li>A) Never</li><li>B) When you need raw retention, ML feature storage, or very large volume at lower cost</li></ul>
            <button class="show-answer-btn" id="btn-3" onclick="showAnswer(3)">Show Answer</button>
            <div class="quiz-answer" id="answer-3"><strong>Correct: B.</strong> Lake complements warehouse for raw data, ML, and scale.</div>
        </div>
        <div class="quiz-question">
            <h4>Q4: What is a cube (or semantic layer) used for?</h4>
            <ul class="quiz-options"><li>A) Storing raw logs</li><li>B) Pre-aggregated dimensions and measures for fast dashboards and sub-second response</li></ul>
            <button class="show-answer-btn" id="btn-4" onclick="showAnswer(4)">Show Answer</button>
            <div class="quiz-answer" id="answer-4"><strong>Correct: B.</strong> Cubes/semantic layers optimize for BI latency and concurrency.</div>
        </div>
        <div class="quiz-question">
            <h4>Q5: Where is Bronze layer data typically stored?</h4>
            <ul class="quiz-options"><li>A) Only in a cube</li><li>B) Often in object storage (lake) or low-cost storage; Silver/Gold in warehouse or lakehouse</li></ul>
            <button class="show-answer-btn" id="btn-5" onclick="showAnswer(5)">Show Answer</button>
            <div class="quiz-answer" id="answer-5"><strong>Correct: B.</strong> Bronze is raw and voluminous; object storage is cost-effective; Silver/Gold need query performance.</div>
        </div>
    </div>
    <script>function showAnswer(n){var a=document.getElementById('answer-'+n),b=document.getElementById('btn-'+n);if(a&&b){a.classList.add('show');b.disabled=true;b.textContent='Answer Revealed';}}</script>
<script>(function(){function sendHeight(){try{var body=document.body,html=document.documentElement;var h=Math.max(body.scrollHeight,body.offsetHeight,html.scrollHeight,html.offsetHeight,html.clientHeight||0);if(h<=0)return;var path=window.location.pathname||window.location.href||'';var m=path.match(/module-(\d+)\.html/);if(m)window.parent.postMessage({type:'setIframeHeight',height:h,moduleId:parseInt(m[1],10)},'*');}catch(e){}}sendHeight();setTimeout(sendHeight,100);setTimeout(sendHeight,400);setTimeout(sendHeight,1000);})();</script>
</body>
</html>
